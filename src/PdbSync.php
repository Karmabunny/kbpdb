<?php
/**
 * @link      https://github.com/Karmabunny
 * @copyright Copyright (c) 2021 Karmabunny
 */

namespace karmabunny\pdb;

use DOMDocument;
use Exception;
use karmabunny\kb\Enc;
use karmabunny\pdb\Exceptions\QueryException;


/**
* Provides a system for syncing a database to a database definition.
*
* The database definition is stored in one or more XML files, which get merged
* together before the sync is done.
* Contains code that may be MySQL specific.
**/
class PdbSync
{
    /** @var Pdb */
    private $pdb;

    /** @var string */
    private $database;

    /** @var bool */
    private $act;

    public $tables;
    private $views;
    private $default_attrs;
    private $load_errors;
    private $extant_tables = null;

    /** Temporarily stores heading to attach to next query generated */
    private $heading = "<p><b>TBA</b>\n";

    /** Set of queries to run. Stored out of order, then ordered and run once all queries have been generated */
    private $queries = [];

    /* Types of queries generated by running a sync, in the order that they should be run */
    private static $query_types = [
        'alter_table',
        'alter_column',
        'rename_table',
        'rename_col',
        'drop_fk',
        'drop_index',
        'drop_column',
        'add_table',
        'insert_record',
        'add_column',
        'add_index',
        'alter_pk',
        'add_fk',
    ];


    /**
    * MySQL names for the foreign key actions
    **/
    private static $foreign_key_actions = [
        'restrict' => 'RESTRICT',
        'set-null' => 'SET NULL',
        'cascade' => 'CASCADE',
    ];


    /**
     * Initial loading and set-up
     *
     * @param Pdb|PdbConfig|array $config
     * @param bool $act True if queries should be run, false if they shouldn't (i.e. a dry-run)
     **/
    public function __construct($config, $act)
    {
        if ($config instanceof Pdb) {
            $this->pdb = $config;
        }
        else {
            $this->pdb = new Pdb($config);
        }

        $this->database = $this->pdb->config->database;
        $this->prefix = $this->pdb->config->prefix;
        $this->act = $act;

        $this->default_attrs = [
            'table' => ['engine' => 'InnoDB', 'charset' => 'utf8', 'collate' => 'utf8_unicode_ci'],
            'column' => ['allownull' => 1],
            'index' => ['type' => 'index']
        ];

        $this->tables = [];
        $this->views = [];
        $this->load_errors = [];
    }


    /**
    * Are the permissions of the current user adequate?
    *
    * Return TRUE on success, or an array of missing permissions on failure.
    **/
    public function checkConnPermissions()
    {
        // SQLite doesn't have users/permissions.
        if ($this->pdb->config->type === 'sqlite') return true;

        $q = "SHOW GRANTS FOR CURRENT_USER()";
        $res = $this->pdb->query($q, [], 'col');

        $perms = [];
        $matches = null;
        foreach ($res as $val) {
            preg_match('!GRANT (.+) ON!', $val, $matches);
            $p = explode(', ', strtoupper($matches[1]));
            $perms = array_merge($perms, $p);
        }

        if (in_array('ALL PRIVILEGES', $perms)) {
            return true;
        }

        $require = ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'ALTER', 'DROP'];
        $missing = array_diff($require, $perms);
        if (count($missing) == 0) return true;

        return $missing;
    }


    /**
    * Executes a set of ALTER TABLE statements which will sync the database to the provided layout
    *
    * @param array $do Which functions to perform. If null, defaults to all functions.
    *    Should be an array of key => val, key = function name, val = 1 to do action, 0 to skip.
    *    Functions:
    *       create    create table, update table attributes
    *       primary   update primary key
    *       column    create/modify columns
    *       index     update indexes
    *       remove    remove columns
    *    If any keys in the specified array do not exist, they will default to skip.
    * @return string HTML processing log
    **/
    public function updateDatabase($do = null)
    {
        if ($do == null) {
            $do = ['create' => 1, 'primary' => 1, 'column' => 1, 'index' => 1, 'foreign_key' => 1, 'remove' => 1];
        }

        $out = '';

        ob_start();
        foreach ($this->tables as $table_name => $table_def) {
            // Check the table exists
            $new_table = false;
            if ($do['create']) {
                if (! $this->checkTableMatches($table_name, $table_def)) {
                    $new_table = true;
                }
            }

            // Check the primary key patches
            if (!$new_table and $do['primary']) {
                if (! $this->checkPrimaryMatches($table_name, $table_def['primary_key'])) {
                    $this->changePrimary($table_name, $table_def['primary_key']);
                }
            }

            // Check each column
            if (!$new_table and $do['column']) {
                $prev_column = '';
                foreach ($table_def['columns'] as $column) {
                    $this->checkColumnMatches($table_name, $column, $prev_column);
                    $prev_column = $column['name'];
                }
            }

            // Check each index
            if (!$new_table and $do['index']) {
                foreach ($table_def['indexes'] as $index) {
                    $this->checkIndexMatches($table_name, $index);
                }
            }

            // Check each foreign key
            if ($do['foreign_key']) {
                foreach ($table_def['foreign_keys'] as $index) {
                    $this->checkForeignKeyMatches($table_name, $index);
                }
            }

            // Remove old columns
            if (!$new_table and $do['remove']) {
                $this->checkRemovedColumns($table_name, $table_def['columns']);
                $this->checkRemovedIndexes($table_name, $table_def['indexes']);
                $this->checkRemovedForeignKeys($table_name, $table_def['foreign_keys']);
            }
        }

        foreach (self::$query_types as $type) {
            if (empty($this->queries[$type])) continue;
            foreach ($this->queries[$type] as $query_data) {
                list($query, $heading, $message) = $query_data;
                echo $heading;
                $this->reportAndExecute($query);
                echo $message;
            }
        }

        $html = ob_get_clean();
        if ($html) {
            $out .= "<h3>Tables</h3>\n";
            $out .= $html;
        }

        ob_start();
        foreach ($this->views as $view_name => $view_def) {
            $this->createView($view_name, $view_def);
        }
        $html = ob_get_clean();
        if ($html) {
            $out .= "<h3>Views</h3>\n";
            $out .= $html;
        }

        return $out;
    }


    /**
    * Checks that the specified table exists
    * If the table does not exist, it will be created.
    *
    * @param string $table_name The name of the table to check
    * @param array $table_def The table definition
    *
    * @return bool False if the table did not exist and was just then created, true otherwise
    **/
    private function checkTableMatches($table_name, $table_def)
    {
        $table_name = trim($table_name);

        // If the table does not exist, create it
        if (! $this->tableExists($table_name)) {
            $previous_found = false;
            if (isset($table_def['attrs']['previous-names'])) {
                $names = explode(',', $table_def['attrs']['previous-names']);

                // Search previous names for a match; if found the table is renamed
                foreach ($names as $n) {
                    if ($this->tableExists($n)) {
                        $this->heading = "<p class=\"heading\"><b>RENAME</b> Table '{$n}' to '{$table_name}'</p>\n";
                        $q = "RENAME TABLE ~{$n} TO ~{$table_name}";
                        $this->storeQuery('rename_table', $q);
                        $previous_found = true;
                        break;
                    }
                }
            }

            if (!$previous_found) {
                $this->heading = "<p class=\"heading\"><b>MISSING</b> Table '{$table_name}'</p>\n";
                $this->createTable($table_name, $table_def);
            }

            return false;
        }

        $table_name = $this->prefix . $table_name;
        $row = $this->extant_tables[$table_name];

        $bad_engine = false;
        if ($row['Engine'] != $table_def['attrs']['engine']) {
            $bad_engine = true;
        }

        $bad_collate = false;
        if ($row['Collation'] != $table_def['attrs']['collate']) {
            $bad_collate = true;
        }

        if ($bad_engine or $bad_collate) {
            $this->heading = "<p class=\"heading\"><b>ATTRS</b> Table '{$table_name}'</p>\n";

            $q = "ALTER TABLE {$table_name}";
            $q .= " ENGINE = {$table_def['attrs']['engine']},";
            $q .= " CHARACTER SET = '{$table_def['attrs']['charset']}',";
            $q .= " COLLATE = '{$table_def['attrs']['collate']}'";

            $this->storeQuery('alter_table', $q);

            $q = "ALTER TABLE {$table_name}";
            $q .= " CONVERT TO CHARACTER SET {$table_def['attrs']['charset']}";
            $q .= " COLLATE {$table_def['attrs']['collate']}";

            $this->storeQuery('alter_table', $q);
        }

        return true;
    }


    /**
    * Creates a table which matches the specified definition
    *
    * @param string $table_name The name of the table to create
    * @param array $table_def The table definition
    * @tag maybe-error-not-mysql
    **/
    private function createTable($table_name, $table_def)
    {
        Pdb::validateIdentifier($table_name);

        $q = "CREATE TABLE ~{$table_name} (\n";

        foreach ($table_def['columns'] as $column_name => $def) {
            $spec = $this->createSqlColumnSpec($def);
            $q .= "  `{$column_name}` {$spec},\n";
        }

        if (@count($table_def['primary_key'])) {
            $q .= "  PRIMARY KEY (`" . implode('`,`', $table_def['primary_key']) . "`),\n";
        }

        foreach ($table_def['indexes'] as $index) {
            $type = strtoupper($index['type']);
            unset ($index['type']);

            $q .= "  {$type} (`" . implode('`,`', $index) . "`),\n";
        }

        $q = preg_replace("/,\n$/", "\n)", $q);

        $q .= " ENGINE = {$table_def['attrs']['engine']},";
        $q .= " CHARACTER SET = '{$table_def['attrs']['charset']}',";
        $q .= " COLLATE = '{$table_def['attrs']['collate']}'";

        $msg = ($this->act ? "Table created successfully.\n" : '');
        $this->storeQuery('add_table', $q, $msg);


        // Default records
        $pdo = $this->pdb->getConnection();
        foreach ($table_def['default_records'] as $record) {
            $q = "INSERT INTO ~{$table_name} (";

            $vals = '';
            foreach ($record as $col => $val) {
                if ($vals != '') {
                    $q .= ', ';
                    $vals .= ', ';
                }
                $q .= "`{$col}`";
                $vals .= $pdo->quote($val);
            }
            $q .= ") VALUES ({$vals})";

            $this->storeQuery('insert_record', $q);
        }
        return true;
    }


    /**
    * Checks that the specified primary key is correct for the table
    *
    * @param string $table_name The name of the table to check
    * @param array $primary The primary key definition
    * @tag maybe-error-not-mysql
    **/
    private function checkPrimaryMatches($table_name, $primary)
    {
        $columns = $this->fieldList($table_name);

        $key = [];
        foreach ($columns as $col) {
            if ($col['Key'] == 'PRI') {
                $key[] = $col['Field'];
            }
        }

        if ($key == $primary) return true;

        $this->heading = "<p class=\"heading\"><b>PRIMARY</b> Table '{$table_name}'</p>\n";
        return false;
    }


    /**
    * Changes the primary key of a table
    *
    * @param string $table_name The name of the table to alter
    * @param array $primary The new primary key definition
    * @tag maybe-error-not-mysql
    **/
    private function changePrimary($table_name, $primary)
    {
        $table_name = $this->prefix . $table_name;
        $columns = implode (', ', $primary);

        $q = "ALTER TABLE {$table_name} DROP PRIMARY KEY, ADD PRIMARY KEY ({$columns})";
        $this->storeQuery('alter_pk', $q);

        return true;
    }


    /**
    * Checks that the specified column exists in the specified table
    * If the column is incorrect, it will be altered
    * If the column does not exist, it will be created
    *
    * @param string $table_name The name of the table to check
    * @param array $column The column definition to check
    * @param string $prev_column The name of the previous column, for column positioning
    * @tag maybe-error-not-mysql
    **/
    private function checkColumnMatches($table_name, $column, $prev_column)
    {
        $current_columns = [];
        $res = $this->fieldList($table_name);
        foreach ($res as $row) {
            $current_columns[$row['Field']] = $row;
        }

        // If not found, create it
        if (!isset($current_columns[$column['name']])) {
            $spec = $this->createSqlColumnSpec($column);

            // Search for a rename first, if so do it and then return
            $previous_found = false;
            if (isset($column['previous-names'])) {
                $names = explode(',', $column['previous-names']);

                // Search previous names for a match; if found the table is renamed
                foreach ($names as $n) {
                    if (isset($current_columns[$n])) {
                        $this->heading = "<p class=\"heading\"><b>RENAME</b> Column '{$n}' to '{$column['name']}'</p>\n";
                        $q = "ALTER TABLE ~{$table_name} CHANGE COLUMN {$n} {$column['name']} {$spec}";
                        $this->storeQuery('rename_col', $q);
                        return true;
                    }
                }
            }

            $this->heading = "<p class=\"heading\"><b>MISSING</b> Table '{$table_name}', Column '{$column['name']}'</p>\n";
            $q = "ALTER TABLE ~{$table_name} ADD COLUMN {$column['name']} {$spec}";

            // Use the MySQL-only AFTER syntax where possible
            if ($prev_column) {
                $q = ["{$q} AFTER {$prev_column}", $q];
            }

            $this->storeQuery('add_column', $q);

            return true;
        }

        $col = $current_columns[$column['name']];

        $type = $this->typeToUpper($col['Type']);
        $type = preg_replace('/INT\([0-9]+\)/', 'INT', $type);

        if (preg_match('/INT/', $type)) {
            $col['Default'] = (int) $col['Default'];
            $column['default'] = (int) $column['default'];
        }

        $matches = true;
        $reason = '';
        if ($type != $column['type']) {$matches = false; $reason .= "type, ";}

        if ($col['Null'] == 'YES' and $column['allownull'] == 0) {$matches = false; $reason .= "null, ";}
        if ($col['Null'] == 'NO' and $column['allownull'] == 1) {$matches = false; $reason .= "null, ";}

        if ($col['Default'] != $column['default']) {$matches = false; $reason .= "default, ";}

        if ($col['Extra'] == 'auto_increment' and $column['autoinc'] == 0) {$matches = false; $reason .= "autoinc, ";}
        if ($col['Extra'] != 'auto_increment' and $column['autoinc'] == 1) {$matches = false; $reason .= "autoinc, ";}

        if (! $matches) {
            $reason = substr($reason, 0, -2);
            $this->heading = "<p class=\"heading\"><b>COLUMN</b> Table '{$table_name}', Column '{$column['name']}' - {$reason}</p>\n";

            $spec = $this->createSqlColumnSpec($column);
            $q = "ALTER TABLE ~{$table_name} MODIFY COLUMN {$column['name']} {$spec}";
            $this->storeQuery('alter_column', $q);

            return true;
        }

        return true;
    }

    /**
    * Checks that the specified index exists in the table
    * If the index is incorrect, it will be altered
    * If the index does not exist, it will be created
    *
    * @param string $table_name The name of the table to check
    * @param array $index The index definition to check
    * @tag maybe-error-not-mysql
    **/
    private function checkIndexMatches($table_name, $index)
    {
        $indexes = $this->indexList($table_name);
        $table_name = $this->prefix . $table_name;

        $type = strtoupper($index['type']);
        unset ($index['type']);
        $cols = implode(', ', $index);

        $action = 'create';
        foreach ($indexes as $name => $info) {
            if ($info['Columns'] == $index and $info['Type'] == $type) {
                $action = null;
                break;

            } else if ($info['Columns'] == $index) {
                $action = 'changetype';
                break;
            }
        }

        if (! $action) {
            return true;
        }

        $this->heading = "<p class=\"heading\"><b>INDEX</b> Table '{$table_name}', Index ({$cols}) - {$action}</p>\n";

        if ($action != 'create') {
            $q = "ALTER TABLE {$table_name} DROP INDEX {$name}";
            $this->storeQuery('drop_index', $q);
        }

        if ($type != 'INDEX') $type .= ' INDEX';

        $q = "ALTER TABLE {$table_name} ADD {$type} ({$cols})";
        $this->storeQuery('add_index', $q);


        return true;
    }


    /**
    * Checks that the specified foreign key exists in the table
    * If the foreign key is incorrect, it will be altered
    * If the foreign key does not exist, it will be created
    *
    * @param string $table_name The name of the table to check
    * @param array $foreign key The foreign key definition to check
    * @tag maybe-error-not-mysql
    **/
    private function checkForeignKeyMatches($table_name, $foreign_key)
    {
        $delete = self::$foreign_key_actions[$foreign_key['delete']];
        $update = self::$foreign_key_actions[$foreign_key['update']];

        $pf = $this->prefix;
        $current_fks = $this->foreignKeyList($this->database, $table_name);
        foreach ($current_fks as $id => $fk) {
            $ignore = false;
            if ($foreign_key['from_column'] != $fk['COLUMN_NAME']) $ignore = true;
            if ($pf . $foreign_key['to_table'] != $fk['REFERENCED_TABLE_NAME']) $ignore = true;
            if ($foreign_key['to_column'] != $fk['REFERENCED_COLUMN_NAME']) $ignore = true;
            if ($fk['UPDATE_RULE'] != $update or $fk['DELETE_RULE'] != $delete) $ignore = true;
            if ($ignore) unset($current_fks[$id]);
        }

        if (count($current_fks) > 1) {
            echo "<p>Warning - multiple foreign keys found for column:";
            foreach ($current_fks as $row) {
                echo "<br>Use 'ALTER TABLE ~{$table_name} DROP FOREIGN KEY {$row['CONSTRAINT_NAME']}' to drop this fk\n";
            }
            echo "<br>";
        }

        if (count($current_fks) != 0) {
            return true;
        }

        $this->heading = "<p class=\"heading\"><b>FRN KEY</b> Table '{$table_name}', Foreign key {$foreign_key['from_column']} -> {$foreign_key['to_table']}.{$foreign_key['to_column']}</p>\n";

        // Look for records which fail to join to the foreign table
        $message = '';
        try {
            $q = "SELECT COUNT(*)
                FROM ~{$table_name} AS main
                LEFT JOIN ~{$foreign_key['to_table']} AS extant ON main.{$foreign_key['from_column']} = extant.{$foreign_key['to_column']}
                WHERE extant.id IS NULL;";
            $num_invalid_records = $this->pdb->query($q, [], 'val');
            if ($num_invalid_records > 0) {
                echo "<p>Warning - {$num_invalid_records} invalid records found ";
                echo "in <i>{$table_name}</i> table (foreign key on <i>{$foreign_key['from_column']}</i> column)";

                $find_q = str_replace('COUNT(*)', "main.id, main.{$foreign_key['from_column']}", $q);

                $delete_q = "DELETE FROM ~{$table_name}
                    WHERE {$foreign_key['from_column']} NOT IN (SELECT id FROM ~{$foreign_key['to_table']});";

                $null_q = "UPDATE ~{$table_name}
                    SET {$foreign_key['from_column']} = NULL
                    WHERE {$foreign_key['from_column']} NOT IN (SELECT id FROM ~{$foreign_key['to_table']});";

                echo '<div class="columns">';

                echo '<div class="column column-4">';
                echo '<p>Find records:</p>';
                echo '<pre>';
                echo PdbHelpers::prettyQueryIndentation($find_q);
                echo '</pre>';
                echo '</div>';

                echo '<div class="column column-4">';
                echo '<p>Delete records:</p>';
                echo '<pre>';
                echo PdbHelpers::prettyQueryIndentation($delete_q);
                echo '</pre>';
                echo '</div>';

                echo '<div class="column column-4 column-last">';
                echo '<p>NULL offending values:</p>';
                echo '<pre>';
                echo PdbHelpers::prettyQueryIndentation($null_q);
                echo '</pre>';
                echo '</div>';

                echo '</div>';
                echo '<p>&nbsp;</p>';
            }
        } catch (QueryException $ex) {
            $message = "<p>Warning - query error looking for invalid records; does the table '{$foreign_key['to_table']}' exist?</p>\n";
        }

        $q = "ALTER TABLE ~{$table_name} ADD FOREIGN KEY ({$foreign_key['from_column']})
            REFERENCES ~{$foreign_key['to_table']} ({$foreign_key['to_column']})
            ON DELETE {$delete}
            ON UPDATE {$update}";
        $this->storeQuery('add_fk', $q, $message);

        return true;
    }


    /**
    * Find and remove unused columns
    **/
    private function checkRemovedColumns($table_name, $defined_columns)
    {
        $columns = $this->fieldList($table_name);
        $table_name = $this->prefix . $table_name;

        foreach ($columns as $col) {
            $found = false;
            foreach ($defined_columns as $def_col) {
                if ($def_col['name'] == $col['Field']) {
                    $found = true;
                    break;
                }
            }

            if (! $found) {
                // Check column isn't an old name for a column which has been or will be replaced upon sync
                foreach ($defined_columns as $other_col) {
                    if ($other_col['name'] == $col['Field']) continue;

                    if (!$other_col['previous-names']) continue;

                    $prevs = preg_split('/,\s*/', $other_col['previous-names']);
                    if (in_array($col['Field'], $prevs)) {
                        return;
                    }
                }

                $this->heading = "<p class=\"heading\"><b>REMOVED</b> Table '{$table_name}', Column '{$col['Field']}'</p>\n";

                $q = "ALTER TABLE {$table_name} DROP COLUMN {$col['Field']}";
                $this->storeQuery('drop_column', $q);
            }
        }
    }


    /**
    * Find and remove unused indexes
    **/
    private function checkRemovedIndexes($table_name, $defined_indexes)
    {
        $db_indexes = $this->indexList($table_name);
        $table_name = $this->prefix . $table_name;

        foreach ($db_indexes as $db_ind) {
            if ($db_ind['Name'] == 'PRIMARY') continue;

            $found = false;
            foreach ($defined_indexes as $def_index) {
                $def_type = strtoupper($def_index['type']);
                unset ($def_index['type']);
                $def_columns = $def_index;

                if ($def_type == $db_ind['Type'] and $def_columns == $db_ind['Columns']) {
                    $found = true;
                    break;
                }
            }

            if (! $found) {
                $this->heading = "<p class=\"heading\"><b>REMOVED</b> Table '{$table_name}', Index '{$db_ind['Name']}'</p>\n";

                $q = "ALTER TABLE {$table_name} DROP INDEX {$db_ind['Name']}";
                $this->storeQuery('drop_index', $q);
            }
        }
    }


    /**
     * Find and remove unused foreign keys
     *
     * @param string $table_name
     * @param string[] $defined_foreign_keys
     **/
    private function checkRemovedForeignKeys($table_name, $defined_foreign_keys)
    {
        $current_fks = $this->foreignKeyList($table_name);

        $pf = $this->prefix;
        $table_name = $pf . $table_name;

        foreach ($current_fks as $fk) {
            $found = false;
            foreach ($defined_foreign_keys as $def_fk) {
                $delete = self::$foreign_key_actions[$def_fk['delete']];
                $update = self::$foreign_key_actions[$def_fk['update']];

                if ($def_fk['from_column'] == $fk['COLUMN_NAME']
                    and
                    $pf . $def_fk['to_table'] == $fk['REFERENCED_TABLE_NAME']
                    and
                    $def_fk['to_column'] == $fk['REFERENCED_COLUMN_NAME']
                    and
                    $update == $fk['UPDATE_RULE']
                    and
                    $delete == $fk['DELETE_RULE']
                ) {
                    $found = true;
                    break;
                }
            }

            if (! $found) {
                $this->heading = "<p class=\"heading\"><b>REMOVED</b> Table '{$table_name}', Foreign key '{$fk['CONSTRAINT_NAME']}'</p>\n";

                $q = "ALTER TABLE {$table_name} DROP FOREIGN KEY {$fk['CONSTRAINT_NAME']}";
                $this->storeQuery('drop_fk', $q);
            }
        }
    }


    /**
    * Create or update  a view
    **/
    private function createView($view_name, $view_def)
    {
        $view_name = trim($view_name);
        $view_def = trim($view_def);

        $q = "DROP VIEW ~{$view_name}";
        $this->reportAndExecute($q);

        $q = "CREATE VIEW ~{$view_name}\nAS\n\t{$view_def}";
        $this->reportAndExecute($q);
    }


    /**
     * Stores a query in a list of queries to run
     * @param string $type One of the types listed in {@see DatabaseSync::$query_types}
     * @param string|array $query The query or queries.
     *        If an array, each query will be tried until one succeeds or all have failed.
     * @param string $message A message to display after the query
     * @return bool True
     * @throws Exception if unknown query type
     */
    private function storeQuery($type, $query, $message = '')
    {
        if (!in_array($type, self::$query_types)) {
            throw new Exception('Unknown query type: ' . $type);
        }
        $this->queries[$type][] = [$query, $this->heading, $message];
        return true;
    }


    /**
    * Generates the SQL that should be used for a column spec
    *
    * The spec goes in the following location in the query:
    *    ALTER TABLE pizzas ADD COLUMN toppings <spec>
    *
    * @param array $column The column spec which the SQL spec should be based on
    * @tag maybe-error-not-mysql
    **/
    private function createSqlColumnSpec($column)
    {
        $spec = $column['type'];

        $pdo = $this->pdb->getConnection();

        if ($column['allownull'] == 0) $spec .= ' NOT NULL';
        if ($column['autoinc']) $spec .= ' AUTO_INCREMENT';
        if ($column['default']) $spec .= ' DEFAULT ' . $pdo->quote($column['default']);

        return $spec;
    }


    /**
    * Converts a column type definition to its uppercase variant, leaving the
    * data for ENUM and SET fields alone
    */
    private function typeToUpper($type)
    {
        // Don't force ENUM or SET values to be uppercase
        if (preg_match('/^enum\s*\(/i', $type)) {
            $type = 'ENUM' . substr($type, 4);
            return str_replace("', '", "','", $type);
        } else if (preg_match('/^set\s*\(/i', $type)) {
            $type = 'SET' . substr($type, 3);
            return str_replace("', '", "','", $type);
        } else {
            return strtoupper($type);
        }
    }


    /**
    * Outputs and executes the specified query
    *
    * @param string|array $q The SQL statement(s) to execute.
    *        If an array, each query will be tried until one succeeds or all have failed.
    **/
    private function reportAndExecute($q)
    {
        static $log_handler = null;

        if (!$log_handler) {
            $log_handler = function($q) {
                $q = trim($q);
                $q = preg_replace("/,\n$/", "\n)", $q);
                $q = preg_replace('/\n\s*/', "\n    ", $q);
                echo '<pre class="query">', Enc::html($q), "</pre>\n";
            };

            if ($this->act) {
                $this->pdb->addLogger($log_handler);
            }
        }

        if ($this->act) {
            $qs = (array) $q;
            $final_key = array_key_last($qs);

            foreach ($qs as $key => $q) {
                try {
                    $this->pdb->query($q, [], 'pdo');
                    break;
                } catch (QueryException $ex) {
                    if ($key != $final_key) {
                        // Only the final query matters
                        echo '<p class="error">Failed; reverting to fallback query</p>';
                    } else {
                        echo '<ul class="messages all-type-error"><li class="error">', Enc::html($ex->getMessage()), '</li></ul>';
                    }
                }
            }
        } else {
            if (is_array($q)) $q = end($q);
            $log_handler($q);
        }

        return true;
    }
}
